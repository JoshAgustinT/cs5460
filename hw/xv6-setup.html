<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<TITLE>143A Principles of Operating Systems</TITLE>
<LINK HREF="./css/main.css" TYPE="text/css" REL="stylesheet">
<META NAME="Description" CONTENT="Home page of Anton Burtsev.">
<META NAME="Keywords" CONTENT="Anton Burtsev, Burtsev, Anton, cs5460">
<SCRIPT SRC="./scripts/image_switcher.js" LANGUAGE="JavaScript"></SCRIPT>
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
	<TABLE  ID="text" ALIGN="CENTER" WIDTH="600" BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD>
		<DIV ID="tech_nav">
			<A HREF="../index.html">Home</A>
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="30" ALT="" BORDER="0"/>
		</DIV>
	</TD>
	</TR>	
	<TR>
	<TD COLSPAN="4" ALIGN="LEFT" BGCOLOR="#FFFFFF">


		<P>



<h1>Instructions for setting up Vagrant xv6 environment</h1> 

<h2>Compile and Install QEMU</h2> 

<p> Xv6 is a real operating system kernel, and hence, it needs real hardware to
boot.  Fortunatelly, today we can emulate hardware in software. Programs like
QEMU can emulate functionality of the real physical CPU in software. I.e., QEMU
implements the normal CPU loop similar to the one we discussed in class:
fetches an instruction pointed by the instruction pointer register (EIP),
decodes it, performs all permission and condition checks, computes the outcome,
increments EIP and continues to the next instruction. Like a real PC platform,
QEMU emulates hardware boot protocol.  QEMU starts by loading the disk sector
number 0 into the memory location 0x7c00 and jumping to it. Xv6 takes it from
there. At a high level, for xv6 it does not matter if it runs on the real
hardware or under QEMU. Of course, emulation is slower than real hardware, but
besides that as long as QEMU implements the logic of the CPU correctly we do
not see any deviations from a real baremetal execution. Surprisingly, QEMU is
reasonably fast, so you as a human barely notice the difference. </p>

<p> To run xv6 we need to compile and install a version of the QEMU emulator.
Due to some compatibility issues it is impossible to compile QEMU directly on
the openlab/andromeda machines. Instead, we will work inside yet another virtual machine
called Vagrant. Vagrant will start on the andromeda machines, and will boot into
a version of the Ubuntu Linux system. Currently vagrant is installed on Andromeda 
machines 1 through 75: <b>andromeda-1.ics.uci.edu</b> to <b>andromeda-75.ics.uci.edu</b>.
</p>

<p>
	Before you begin, you need to select a andromeda server for yourself.
	We are following the following method to select a server : 
	<ul>
		<li>Find out your student ID <br>
			(Let's say: 66541280)
		</li>
		<li>Evaluate serverNumber = (studentIDNumber mod 74) +1
			<br>Ex: 66541280 => 37
		</li>
		<li>Your server name is : <b>andromeda-{serverNumber}.ics.uci.edu</b>
			<br>Ex: andromeda-37.ics.uci.edu
		</li>
	</ul>
<p>

To start working on this homework, login to your server
<pre> 
$ ssh UCInetID@andromeda-XX.ics.uci.edu
</pre>
I suggest you create a new folder for your ics143a homeworks, like:
<pre>
UCInetID@andromeda-XX$mkdir ics143a
</pre>
Change into that directory: 
<pre>
UCInetID@andromeda-XX$cd ics143a
</pre>
Fetch a version of the vagrant environment that explains to vagrant what kind of virtual machine you're planning to run:  
<pre>
UCInetID@andromeda-XX$ wget http://www.ics.uci.edu/~aburtsev/143A/hw/xv6-vagrant-master.tgz
UCInetID@andromeda-XX$ tar -xzvf xv6-vagrant-master.tgz
</pre>
Change into the new folder
<pre>
UCInetID@andromeda-XX$ cd xv6-vagrant-master
</pre>
Change the name of the vagrant VM to something unique (otherwise we all end up with the same VM and vagrant is confused). In the <tt>Vagrantfile</tt> file change the following line 
<pre>
      vb.name = "xv6_box_anton" # <--- You should change this to make VM names unique
</pre>

Start vagrant VM (this will take several minutes as it is building QEMU inside)
<pre>
UCInetID@andromeda-XX$ vagrant up
</pre>

If vagrant fails with the following message:
<pre>
==> default: Clearing any previously set forwarded ports...
Vagrant cannot forward the specified ports on this VM, since they
would collide with some other application that is already listening
on these ports. The forwarded port to 20000 is already in use
on the host machine.

To fix this, modify your current project's Vagrantfile to use another
port. Example, where '1234' would be replaced by a unique host port:

  config.vm.network :forwarded_port, guest: 26001, host: 1234
</pre>

Go ahead with the suggested fix. Change the following line in the Vagrantfile setting the host port to something random below 64000: 
<pre>
  config.vm.network "forwarded_port", guest: 26001, host: 30000
</pre>

If vagrant VM is up, you're ready to log in inside and start working on your xv6 Linux environment. Log in inside the vagrant VM. From the same folder where Vagrantfile is (i.e., from ics143a/xv6-vagrant-master) type
<pre>
UCInetID@andromeda-XX$ vagrant ssh
</pre>
</p>

Now you're inside the Linux Ubuntu 12.04.5 LTS. Your new vagrant machine should
have everything you need to compile and run your xv6 code. Vagrant
automatically shares the directory of your host machine (i.e.,
odin.ics.uci.edu) where the `Vagrantfile` is as the `/vagrant` directory of the
vagrant VM.  

<h3>Note</h3>

While I provide instructions for how to use Andromeda machines, you are more than welcome 
to configure and run xv6 on your own laptop, desktop, or VM.  
If you decide to use your own environment, see the instructions on the <a
href="https://pdos.csail.mit.edu/6.828/2016/tools.html">xv6 tools</a> page for
how to set up xv6.  I've successfully built xv6 on my Ubuntu 14.04 LTS. I had
to install the following packages in order to build QEMU: libz-dev,
libtool-bin, libtool, libglib2.0-dev, libpixman-1-dev, libfdt-dev. 

<h2>Boot xv6</h2> 

<b>From inside your Vagrant VM</b> fetch the xv6 source:

<pre>
vagrant@odin$ cd /vagrant
vagrant@odin$ mkdir ics143a
vagrant@odin$ cd ics143a
vagrant@odin$ git clone git://github.com/mit-pdos/xv6-public.git
Cloning into xv6...
...
</pre>


Build xv6:
<pre>
vagrant@odin$ cd xv6-public
vagrant@odin$ make 
...
gcc -O -nostdinc -I. -c bootmain.c
gcc -nostdinc -I. -c bootasm.S
ld -m    elf_i386 -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
objdump -S bootblock.o > bootblock.asm
objcopy -S -O binary -j .text bootblock.o bootblock
...
vagrant@odin$ 
</pre>

<p> You're now ready to start working on the assignment. 

<p><p> <h2>Exercise 1: Finding and breaking at an address</h2>

Find the address of <code>_start</code>, the entry point of the kernel:
<pre>
vagrant@odin$ nm kernel | grep _start
8010b50c D _binary_entryother_start
8010b4e0 D _binary_initcode_start
0010000c T _start
vagrant@odin$
</pre>
In this case, the address is <code>0010000c</code>.

<p>
Run the kernel inside QEMU GDB, setting a breakpoint
at <code>_start</code> (i.e., the address
you just found).
</p>

<pre>
vagrant@odin$ make qemu-nox-gdb
...
</pre>

Now open another terminal (<b>you do that on your openlab host machine, i.e., odin or tristram, whichever you're using</b>). Change to the folder 
where Vagrant is configured, and connect to the same Vagrant VM, i.e.: 
<pre>
odin$ cd ~/ics143a/xv6-vagrant-master/
odin$ vagrant ssh
</pre> 

In this new terminal (<b>but now inside your vagrant VM</b>) change to the folder where you've built xv6, and start GDB: 
<pre>
vagrant@odin$ cd /vagrant/ics143a/xv6-public
vagrant@odin$ gdb
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
+ target remote localhost:26000
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file kernel
</pre>
Set a breakpoint at the address of <tt>_start</tt>, e.g.
<pre>
(gdb) br * 0x0010000c
Breakpoint 1 at 0x10000c
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0x10000c:	mov    %cr4,%eax

Breakpoint 1, 0x0010000c in ?? ()
(gdb)
</pre>

The details of what you see are likely to differ from the above output.

<p>You can find more information about QEMU monitor and GDB debugger  <a
href="https://pdos.csail.mit.edu/6.828/2011/labguide.html">here</a>, feel free
to explore them.  </p>


</div>

	</TD>			
	</TR>
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD COLSPAN="4">
		<DIV ID="tech">Updated: October, 2017</DIV>
	</TD>
	</TR>
	</TABLE>
</BODY>
</HTML>


